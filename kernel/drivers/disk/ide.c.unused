//PCI IDE driver

//includes
#include "../io/io.h"
#include "../../kernel/kernelFunctions.h"
#include "../video/videoText.h"
#include "../../libc/function.h"

//status
#define ATA_SR_BUSY	0x80
#define ATA_SR_DRDY 0x40
#define ATA_SR_DF   0x20
#define ATA_SR_DSC  0x10
#define ATA_SR_DRQ  0x08
#define ATA_SR_CORR 0x04
#define ATA_SR_IDX  0x02
#define ATA_SR_ERR 	0x01

//errors

#define ATA_ER_BBK      0x80
#define ATA_ER_UNC      0x40
#define ATA_ER_MC       0x20
#define ATA_ER_IDNF     0x10
#define ATA_ER_MCR      0x08
#define ATA_ER_ABRT     0x04
#define ATA_ER_TK0NF    0x02
#define ATA_ER_AMNF 	0x01

//commands
#define ATA_CMD_READ_PIO         0x20
#define ATA_CMD_READ_PIO_EXT     0x24
#define ATA_CMD_READ_DMA         0xC8
#define ATA_CMD_READ_DMA_EXT     0x25
#define ATA_CMD_WRITE_PIO        0x30
#define ATA_CMD_WRITE_PIO_EXT    0x34
#define ATA_CMD_WRITE_DMA        0xCA
#define ATA_CMD_WRITE_DMA_EXT    0x35
#define ATA_CMD_CACHE_FLUSH      0xE7
#define ATA_CMD_CACHE_FLUSH_EXT  0xEA
#define ATA_CMD_PACKET           0xA0
#define ATA_CMD_IDENTIFY_PACKET  0xA1
#define ATA_CMD_IDENTIFY         0xEC

//atapi commands
#define ATAPI_CMD_READ	0xA8
#define ATAPI_CMD_EJECT 0x1B

//indents
#define ATA_IDENT_DEVICETYPE   	0
#define ATA_IDENT_CYLINDERS   	2
#define ATA_IDENT_HEADS      	6
#define ATA_IDENT_SECTORS      	12
#define ATA_IDENT_SERIAL   		20
#define ATA_IDENT_MODEL      	54
#define ATA_IDENT_CAPABILITIES  98
#define ATA_IDENT_FIELDVALID   	106
#define ATA_IDENT_MAX_LBA   	120
#define ATA_IDENT_COMMANDSETS   164
#define ATA_IDENT_MAX_LBA_EXT   200

//master/slave
#define ATA_MASTER 0x00
#define ATA_SLAVE  0x01


//ports (ata/atapi task file)
#define ATA_REG_DATA      	0x00
#define ATA_REG_ERROR      	0x01
#define ATA_REG_FEATURES   	0x01
#define ATA_REG_SECCOUNT0   0x02
#define ATA_REG_LBA0      	0x03
#define ATA_REG_LBA1      	0x04
#define ATA_REG_LBA2      	0x05
#define ATA_REG_HDDEVSEL   	0x06
#define ATA_REG_COMMAND     0x07
#define ATA_REG_STATUS      0x07
#define ATA_REG_SECCOUNT1   0x08
#define ATA_REG_LBA3      	0x09
#define ATA_REG_LBA4      	0x0A
#define ATA_REG_LBA5      	0x0B
#define ATA_REG_CONTROL     0x0C
#define ATA_REG_ALTSTATUS   0x0C
#define ATA_REG_DEVADDRESS  0x0D

//channels
#define ATA_PRIMARY		0x00
#define ATA_SECONDARY	0x01

//directions
#define ATA_READ  0x00
#define ATA_WRITE 0x01

//types
#define IDE_ATA   0x00
#define IDE_ATAPI 0x01


struct channel{
	unsigned short base; 	// I/O base
	unsigned short ctrl;	// control base
	unsigned short bmide; 	// bus master IDE
	unsigned short nIEN;	// nIEN (No interrupt)
} channels[2];

unsigned char ide_buf[2048] = {0};
static unsigned char ide_irq_invoked = 0;
static unsigned char atapi_packet[12] = {0xA8, 0, 0, 0 ,0, 0, 0, 0, 8, 0, 0, 0};

struct ide_device{
	unsigned char reserved;			// Empty, drive exists (0x00, 0x01)
	unsigned char channel;			// primairy channel or secondairy (0x00, 0x01)
	unsigned char drive;			// Master, Slave (0x00, 0x01)
	unsigned short type;			// ATA, ATAPI (0x00,0x01)
	unsigned short sign;			// drive signature
	unsigned short capabilities;	// capabilities
	unsigned int commandsets;		// command set supported
	unsigned int size;				// size in sectors
	unsigned char model[41];		// model in a string
}ide_devices[4];

void ide_write(unsigned char channel, unsigned char reg, unsigned char data){
	if (reg > 0x07 && reg < 0x0c) ide_write(channel, ATA_REG_CONTROL, 0x80 | channels[channel].nIEN);
	if (reg < 0x08) port_byte_out(channels[channel].base + reg - 0x00, data);
	else if (reg < 0x0c) port_byte_out(channels[channel].base + reg - 0x06, data);
	else if (reg < 0x0e) port_byte_out(channels[channel].ctrl + reg - 0x0a, data);
	else if (reg < 0x16) port_byte_out(channels[channel].bmide + reg - 0x0e, data);
	if (reg > 0x07 && reg < 0x0c) ide_write(channel, ATA_REG_CONTROL, channels[channel].nIEN);
}

unsigned char ide_read(unsigned char channel, unsigned char reg) {
	unsigned char result;
	if (reg > 0x07 && reg < 0x0c) ide_write(channel, ATA_REG_CONTROL, 0x80 | channels[channel].nIEN);
	if (reg < 0x08) result = port_byte_in(channels[channel].base + reg - 0x00);
	else if (reg < 0x0c) result = port_byte_in(channels[channel].base + reg - 0x06);
	else if (reg < 0x0e) result = port_byte_in(channels[channel].ctrl + reg - 0x0a);
	else if (reg < 0x16) result = port_byte_in(channels[channel].bmide + reg - 0x0e);
	if (reg > 0x07 && reg < 0x0c) ide_write(channel, ATA_REG_CONTROL, channels[channel].nIEN);
	return result;
}

void ide_read_buffer(unsigned char channel, unsigned char reg, unsigned int buffer, unsigned int quads) {
	if (reg > 0x07 && reg < 0x0c) ide_write(channel, ATA_REG_CONTROL, 0x80 | channels[channel].nIEN);
	asm("pushw %es; pushw %ax; movw %ds, %ax; movw %ax, %es; popw %ax;");										//bug???
	if (reg < 0x0c) insl(channels[channel].base + reg - 0x00, buffer, quads);
	else if (reg < 0x0c) insl(channels[channel].base + reg - 0x06, buffer, quads);
	else if (reg < 0x0e) insl(channels[channel].ctrl + reg - 0x0a, buffer, quads);
	else if (reg < 0x16) insl(channels[channel].bmide + reg - 0x0e, buffer, quads);
	asm("popw %es;");
	if (reg > 0x07 && reg < 0x0c) ide_write(channel, ATA_REG_CONTROL, channels[channel].nIEN);
}

unsigned char ide_polling(unsigned char channel, unsigned int advanced_check) {
	// delay 400 ns
	ide_read(channel, ATA_REG_ALTSTATUS);
	ide_read(channel, ATA_REG_ALTSTATUS);
	ide_read(channel, ATA_REG_ALTSTATUS);
	ide_read(channel, ATA_REG_ALTSTATUS);

	while (ide_read(channel, ATA_REG_ALTSTATUS & ATA_SR_BUSY)); // wait for disk to not be busy
	if (advanced_check){
		unsigned char state = ide_read(channel, ATA_REG_STATUS);

		if (state & ATA_SR_ERR) return 2; 		// error
		if (state & ATA_SR_DF) return 1;  		// device fault
		if (!(state & ATA_SR_DRQ)) return 3; 	// drq should have been set
	}
	return 0; 
}

unsigned char ide_print_error(unsigned int drive, unsigned char error){
	if (error == 0) return error;

	// todo create this function 
	UNUSED(drive);
	return 0;

}

void ide_initialize(unsigned int BAR0, unsigned int BAR1, unsigned int BAR2, unsigned int BAR3, unsigned int BAR4){
	int j, k, count = 0;

	// detect I/O ports which interface with IDE controller

	channels[ATA_PRIMARY].base    = (BAR0 & 0xFFFFFFFC) + 0x1F0*(!BAR0);
	channels[ATA_PRIMARY].ctrl    = (BAR1 & 0xFFFFFFFC) + 0x3F4*(!BAR1);
	channels[ATA_SECONDARY].base  = (BAR2 & 0xFFFFFFFC) + 0x170*(!BAR2);
	channels[ATA_SECONDARY].ctrl  = (BAR3 & 0xFFFFFFFC) + 0x374*(!BAR3);
	channels[ATA_PRIMARY].bmide   = (BAR4 & 0xFFFFFFFC) + 0;
	channels[ATA_SECONDARY].bmide = (BAR4 & 0xFFFFFFFC) + 8;

	// disable IRQS
	ide_write(ATA_PRIMARY,   ATA_REG_CONTROL, 2);
	ide_write(ATA_SECONDARY, ATA_REG_CONTROL, 2);

	// detect ATA-ATAPI devices

	for (int i=0; i < 2; i++){
		for (j = 0; j < 2; j++){
			unsigned char error = 0;
			unsigned char type  = IDE_ATA;
			ide_devices[count].reserved = 0;

			ide_write(i, ATA_REG_HDDEVSEL, 0xA0 | (j << 4));
			sleep(1); // 1 ms (prolly doesn't wait so this could be a bug) 					// bug??

			ide_write(i, ATA_REG_COMMAND, ATA_CMD_IDENTIFY);
			sleep(1);

			if (!(ide_read(i, ATA_REG_STATUS))) continue; // no device
			while (1){
				unsigned char status = ide_read(i, ATA_REG_STATUS);
				if (  status & ATA_SR_ERR ){error=1; break;}
				if (!(status & ATA_SR_BUSY)) break;
			}

			if (error){
				unsigned char cl = ide_read(i, ATA_REG_LBA1);
				unsigned char ch = ide_read(i, ATA_REG_LBA2);

				if (cl == 0x10 && ch == 0xeb) type = IDE_ATAPI;
				else if (cl == 0x69 && ch == 0x96) type = IDE_ATAPI;
				else continue;
				ide_write(i, ATA_REG_COMMAND, ATA_CMD_IDENTIFY_PACKET);
				sleep(1);
			}

			ide_read_buffer(i, ATA_REG_DATA, (unsigned int) ide_buf, 128);

			ide_devices[count].reserved = 1;
			ide_devices[count].type = type;
			ide_devices[count].channel = i;
			ide_devices[count].drive = j;
			ide_devices[count].sign = ((unsigned short *)(ide_buf + ATA_IDENT_DEVICETYPE))[0];
			ide_devices[count].capabilities = ((unsigned short*) (ide_buf + ATA_IDENT_CAPABILITIES))[0];
			ide_devices[count].commandsets = ((unsigned int *)(ide_buf + ATA_IDENT_COMMANDSETS))[0];

			if (ide_devices[count].commandsets & (1 << 26)){
				ide_devices[count].size = ((unsigned int *) (ide_buf + ATA_IDENT_MAX_LBA_EXT))[0];
			} else {
				ide_devices[count].size = ((unsigned int *) (ide_buf + ATA_IDENT_MAX_LBA))[0];
			}

			for (k = ATA_IDENT_MODEL; k < (ATA_IDENT_MODEL + 40); k+= 2){
				ide_devices[count].model[k-ATA_IDENT_MODEL] = ide_buf[k+1];
				ide_devices[count].model[(k+1)-ATA_IDENT_MODEL] = ide_buf[k];
			}
			ide_devices[count].model[40] = '0'; 
			count++;
		}
		
	}
	for(int i=0; i<4; i++){
		if (ide_devices[i].reserved){
			print("\nFound stuff type: "); print_int(ide_devices[i].type); print(" and size: "); print_int(ide_devices[i].size/1024/1024);
			//print(" and model name: "); print(ide_devices[i].model);
		}
	}
}

/*
	writing to disk:
	------------------------
	- LBA28 mode (only goes up until 128GB)
	- LBA48 mode (up to 2TB (int in 32 bit))
	- Cylinder head selector
	
	reading from disk:
	- PIO modes (0 - 6) // slower than DMA
	- Single word DMA (0, 1, 2)
	- Double word DMA (0, 1, 2)

	polling modes:
	- IRQ's
	- Polling status 	(singletasking)

*/
// todo finish this driver

unsigned char ide_ata_access(unsigned char direction, unsigned char drive, unsigned int lba, unsigned char numsects,\
							 unsigned short selector, unsigned int edi){
	unsigned char lba_mode, dma, cmd;
	unsigned char lba_io[6];
	unsigned int channel;
	unsigned int slavebit;
	unsigned int bus;
	unsigned int words;
	unsigned short cyl, i;
	unsigned char head, sect, err;

	ide_write(channel, ATA_REG_CONTROL, channels[channel].nIEN = (ide_irq_invoked = 0x0) + 0x02);

	// select which mode to use

	if (lba >= 0x10000000) {
		// LBA48:
      	lba_mode  = 2;
      	lba_io[0] = (lba & 0x000000FF)>> 0;
      	lba_io[1] = (lba & 0x0000FF00)>> 8;
      	lba_io[2] = (lba & 0x00FF0000)>>16;
      	lba_io[3] = (lba & 0xFF000000)>>24;
      	lba_io[4] = 0; // lba is an integer so 32bit should be enough to be ablte to access a 2TB disk
      	lba_io[5] = 0; // lba is an integer so 32bit should be enough to be ablte to access a 2TB disk
      	head      = 0; 
   } else if (ide_devices[drive].capabilities & 0x200)  {
      	// LBA28:
      	lba_mode  = 1;
      	lba_io[0] = (lba & 0x00000FF)>> 0;
      	lba_io[1] = (lba & 0x000FF00)>> 8;
      	lba_io[2] = (lba & 0x0FF0000)>>16;
      	lba_io[3] = 0; // These Registers are not used here.
      	lba_io[4] = 0; // These Registers are not used here.
      	lba_io[5] = 0; // These Registers are not used here.
      	head      = (lba & 0xF000000)>>24;
   } else {
      	// CHS:
      	lba_mode  = 0;
      	sect      = (lba % 63) + 1;
      	cyl       = (lba + 1  - sect)/(16*63);
      	lba_io[0] = sect;
      	lba_io[1] = (cyl>>0) & 0xFF;
      	lba_io[2] = (cyl>>8) & 0xFF;
      	lba_io[3] = 0;
      	lba_io[4] = 0;
      	lba_io[5] = 0;
     	head      = (lba + 1  - sect)%(16*63)/(63);
   }
   dma = 0;
   while (ide_read(channel, ATA_REG_STATUS) & ATA_SR_BUSY);
   if (lba_mode == 0) ide_write(channel, ATA_REG_HDDEVSEL, 0xA0 | (slavebit<<4) | head);
   else         ide_write(channel, ATA_REG_HDDEVSEL, 0xE0 | (slavebit<<4) | head);

   if (lba_mode == 2) {
    	ide_write(channel, ATA_REG_SECCOUNT1,   0);
      	ide_write(channel, ATA_REG_LBA3,   lba_io[3]);
      	ide_write(channel, ATA_REG_LBA4,   lba_io[4]);
      	ide_write(channel, ATA_REG_LBA5,   lba_io[5]);
   }
   ide_write(channel, ATA_REG_SECCOUNT0,   numsects);
   ide_write(channel, ATA_REG_LBA0,   lba_io[0]);
   ide_write(channel, ATA_REG_LBA1,   lba_io[1]);
   ide_write(channel, ATA_REG_LBA2,   lba_io[2]);

   if (lba_mode == 0 && dma == 0 && direction == 0) cmd = ATA_CMD_READ_PIO;
   if (lba_mode == 1 && dma == 0 && direction == 0) cmd = ATA_CMD_READ_PIO;   
   if (lba_mode == 2 && dma == 0 && direction == 0) cmd = ATA_CMD_READ_PIO_EXT;   
   if (lba_mode == 0 && dma == 1 && direction == 0) cmd = ATA_CMD_READ_DMA;
   if (lba_mode == 1 && dma == 1 && direction == 0) cmd = ATA_CMD_READ_DMA;
   if (lba_mode == 2 && dma == 1 && direction == 0) cmd = ATA_CMD_READ_DMA_EXT;
   if (lba_mode == 0 && dma == 0 && direction == 1) cmd = ATA_CMD_WRITE_PIO;
   if (lba_mode == 1 && dma == 0 && direction == 1) cmd = ATA_CMD_WRITE_PIO;
   if (lba_mode == 2 && dma == 0 && direction == 1) cmd = ATA_CMD_WRITE_PIO_EXT;
   if (lba_mode == 0 && dma == 1 && direction == 1) cmd = ATA_CMD_WRITE_DMA;
   if (lba_mode == 1 && dma == 1 && direction == 1) cmd = ATA_CMD_WRITE_DMA;
   if (lba_mode == 2 && dma == 1 && direction == 1) cmd = ATA_CMD_WRITE_DMA_EXT;
   ide_write(channel, ATA_REG_COMMAND, cmd);

   if (dma){
      if (direction == 0){}
      	// DMA Read.
      else{}
      	// DMA Write.
  }
   	else{
      if (direction == 0){
      // PIO Read.
      	for (i = 0; i < numsects; i++) {
        	if ( (err = ide_polling(channel, 1)) ){
        		return err;
        	}
         	asm("pushw %es");
         	asm("mov %%ax, %%es"::"a"(selector));
         	asm("rep insw"::"c"(words), "d"(bus), "D"(edi)); // Receive Data.
         	asm("popw %es");
         	edi += (words*2);
        	}
      	} else {
      	// PIO Write.
      	for (i = 0; i < numsects; i++) {
        	ide_polling(channel, 0); // Polling.
         	asm("pushw %ds");
         	asm("mov %%ax, %%ds"::"a"(selector));
         	asm("rep outsw"::"c"(words), "d"(bus), "S"(edi)); // Send Data
         	asm("popw %ds");
         	edi += (words*2);
        	}
      
      	ide_write(channel, ATA_REG_COMMAND, (char []) {   ATA_CMD_CACHE_FLUSH,
                        ATA_CMD_CACHE_FLUSH,
                        ATA_CMD_CACHE_FLUSH_EXT}[lba_mode]);
      	ide_polling(channel, 0); // Polling.
      }
  	}
   	return 0;

}

void ide_wait_irq() {
   while (!ide_irq_invoked);
   ide_irq_invoked = 0;
}

void ide_irq(){
	ide_irq_invoked = 1;
}

unsigned char ide_atapi_read(unsigned char drive, unsigned int lba, unsigned char numsects, unsigned short selector, unsigned int edi){
	unsigned int   channel  = ide_devices[drive].channel;
   	unsigned int   slavebit = ide_devices[drive].drive;
   	unsigned int   bus      = channels[channel].base;
   	unsigned int   words    = 2048 / 2; // Sector Size in Words, Almost All ATAPI Drives has a sector size of 2048 bytes.
   	unsigned char  err; int i;

   	ide_write(channel, ATA_REG_CONTROL, channels[channel].nIEN = ide_irq_invoked = 0x0);

   	atapi_packet[ 0] = ATAPI_CMD_READ;
   	atapi_packet[ 1] = 0x0;
   	atapi_packet[ 2] = (lba>>24) & 0xFF;
   	atapi_packet[ 3] = (lba>>16) & 0xFF;
   	atapi_packet[ 4] = (lba>> 8) & 0xFF;
  	atapi_packet[ 5] = (lba>> 0) & 0xFF;
   	atapi_packet[ 6] = 0x0;
   	atapi_packet[ 7] = 0x0;
   	atapi_packet[ 8] = 0x0;
   	atapi_packet[ 9] = numsects;
   	atapi_packet[10] = 0x0;
   	atapi_packet[11] = 0x0;

   	ide_write(channel, ATA_REG_HDDEVSEL, slavebit<<4);

   	ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.
   	ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.
   	ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.
   	ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.

   	ide_write(channel, ATA_REG_FEATURES, 0);

   	ide_write(channel, ATA_REG_LBA1, (words * 2) & 0xFF);
   	ide_write(channel, ATA_REG_LBA2, (words * 2)>>8);

   	ide_write(channel, ATA_REG_COMMAND, ATA_CMD_PACKET);

	if ( (err = ide_polling(channel, 1)) ) return err;

	asm("rep   outsw"::"c"(6), "d"(bus), "S"(atapi_packet));

	for (i = 0; i < numsects; i++) {
      	ide_wait_irq();
      	if ( (err = ide_polling(channel, 1)) ) return err;
      	asm("pushw %es");
      	asm("mov %%ax, %%es"::"a"(selector));
      	asm("rep insw"::"c"(words), "d"(bus), "D"(edi));// Receive Data.
      	asm("popw %es");
      	edi += (words*2);
   }

   ide_wait_irq();
   while (ide_read(channel, ATA_REG_STATUS) & (ATA_SR_BUSY | ATA_SR_DRQ));

   return 0;
}

void ide_read_sectors(unsigned char drive, unsigned char numsects, unsigned int lba, unsigned short es, unsigned int edi) {
   	char package[5];
   	// 1: Check if the drive presents:
   	// ==================================
   	if (drive > 3 || ide_devices[drive].reserved == 0) package[0] = 0x1;      // Drive Not Found!

   	// 2: Check if inputs are valid:
   	// ==================================
   	else if (((lba + numsects) > ide_devices[drive].size) && (ide_devices[drive].type == IDE_ATA))
    	package[0] = 0x2;                     // Seeking to invalid position.

   // 3: Read in PIO Mode through Polling & IRQs:
   // ============================================
   	else {
      	unsigned char err;
      	if (ide_devices[drive].type == IDE_ATA)
        	err = ide_ata_access(ATA_READ, drive, lba, numsects, es, edi);
      	else if (ide_devices[drive].type == IDE_ATAPI)
         	for (int i = 0; i < numsects; i++)
            	err = ide_atapi_read(drive, lba + i, 1, es, edi + (i*2048));
      	package[0] = ide_print_error(drive, err);
   }
}

void ide_write_sectors(unsigned char drive, unsigned char numsects, unsigned int lba, unsigned short es, unsigned int edi) {
	char package[5];
   // 1: Check if the drive presents:
   // ==================================
   if (drive > 3 || ide_devices[drive].reserved == 0) package[0] = 0x1;      // Drive Not Found!
   // 2: Check if inputs are valid:
   // ==================================
   else if (((lba + numsects) > ide_devices[drive].size) && (ide_devices[drive].type == IDE_ATA))
      package[0] = 0x2;                     // Seeking to invalid position.
   // 3: Read in PIO Mode through Polling & IRQs:
   // ============================================
   else {
      unsigned char err;
      if (ide_devices[drive].type == IDE_ATA)
         err = ide_ata_access(ATA_WRITE, drive, lba, numsects, es, edi);
      else if (ide_devices[drive].type == IDE_ATAPI)
         err = 4; // Write-Protected.
      package[0] = ide_print_error(drive, err);
   }
}

void ide_atapi_eject(unsigned char drive) {
   unsigned int   channel      = ide_devices[drive].channel;
   unsigned int   slavebit      = ide_devices[drive].drive;
   unsigned int   bus      = channels[channel].base;
   unsigned int   words      = 2048 / 2;               // Sector Size in Words.
   unsigned char  err = 0;
   ide_irq_invoked = 0;
   char package[5];

   // 1: Check if the drive presents:
   // ==================================
   if (drive > 3 || ide_devices[drive].reserved == 0) package[0] = 0x1;      // Drive Not Found!
   // 2: Check if drive isn't ATAPI:
   // ==================================
   else if (ide_devices[drive].type == IDE_ATA) package[0] = 20;         // Command Aborted.
   // 3: Eject ATAPI Driver:
   // ============================================
   else {
      // Enable IRQs:
      ide_write(channel, ATA_REG_CONTROL, channels[channel].nIEN = ide_irq_invoked = 0x0);

      // (I): Setup SCSI Packet:
      // ------------------------------------------------------------------
      atapi_packet[ 0] = ATAPI_CMD_EJECT;
      atapi_packet[ 1] = 0x00;
      atapi_packet[ 2] = 0x00;
      atapi_packet[ 3] = 0x00;
      atapi_packet[ 4] = 0x02;
      atapi_packet[ 5] = 0x00;
      atapi_packet[ 6] = 0x00;
      atapi_packet[ 7] = 0x00;
      atapi_packet[ 8] = 0x00;
      atapi_packet[ 9] = 0x00;
      atapi_packet[10] = 0x00;
      atapi_packet[11] = 0x00;

      // (II): Select the Drive:
      // ------------------------------------------------------------------
      ide_write(channel, ATA_REG_HDDEVSEL, slavebit<<4);

      // (III): Delay 400 nanosecond for select to complete:
      // ------------------------------------------------------------------
      ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.
      ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.
      ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.
      ide_read(channel, ATA_REG_ALTSTATUS); // Reading Alternate Status Port wastes 100ns.

      // (IV): Send the Packet Command:
      // ------------------------------------------------------------------
      ide_write(channel, ATA_REG_COMMAND, ATA_CMD_PACKET);      // Send the Command.

      // (V): Waiting for the driver to finish or invoke an error:
      // ------------------------------------------------------------------
      if (err = ide_polling(channel, 1));            // Polling and stop if error.

      // (VI): Sending the packet data:
      // ------------------------------------------------------------------
      else {
         asm("rep   outsw"::"c"(6), "d"(bus), "S"(atapi_packet));// Send Packet Data
         ide_wait_irq();                  // Wait for an IRQ.
         err = ide_polling(channel, 1);            // Polling and get error code.
         if (err == 3) err = 0; // DRQ is not needed here.
      }
      package[0] = ide_print_error(drive, err); // Return;

   }
}
